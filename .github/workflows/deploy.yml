name: Build and Deploy

on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io

jobs:
  build-image:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.vars.outputs.image }}
      app_name: ${{ steps.vars.outputs.app_name }}
    permissions:
      contents: read
      packages: write
      deployments: write

    environment:
      name: production
      url: https://${{ steps.vars.outputs.app_name }}.outatime.live

    steps:
      # ==================== SETUP ====================
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Set variables
        id: vars
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          APP_NAME=$(basename "$REPO_LOWER")
          echo "image=${{ env.REGISTRY }}/${REPO_LOWER}" >> $GITHUB_OUTPUT
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT

      # ==================== BUILD ====================
      - name: üîê Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üê≥ Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: ${{ steps.vars.outputs.image }}:${{ github.sha }}

      - name: üì§ Push Docker image
        run: |
          docker push ${{ steps.vars.outputs.image }}:${{ github.sha }}
          docker tag ${{ steps.vars.outputs.image }}:${{ github.sha }} ${{ steps.vars.outputs.image }}:latest
          docker push ${{ steps.vars.outputs.image }}:latest

  prepare-cluster:
    needs: build-image
    runs-on: ubuntu-slim
    outputs:
      is_new: ${{ steps.check.outputs.is_new }}
    permissions:
      contents: read
      packages: write
      deployments: write

    environment:
      name: production
      url: https://${{ needs.build-image.outputs.app_name }}.outatime.live

    steps:
      # ==================== DEPLOY SETUP ====================
      - name: üõ†Ô∏è Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: üîë Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

      - name: üîç Check if new deployment
        id: check
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          if kubectl get deployment $APP_NAME -n $APP_NAME &> /dev/null; then
            echo "is_new=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Existing deployment found - will rollback on failure"
          else
            echo "is_new=true" >> $GITHUB_OUTPUT
            echo "üÜï New deployment - will cleanup on failure"
          fi

      # ==================== NAMESPACE ====================
      - name: üìÅ Create namespace
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl create namespace $APP_NAME --dry-run=client -o yaml | kubectl apply -f -

      - name: ‚è≥ Wait for pull secret
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          for i in {1..12}; do
            if kubectl get secret ghcr-org-secret -n $APP_NAME &> /dev/null; then
              echo "‚úÖ Pull secret available"
              exit 0
            fi
            echo "Waiting for pull secret... (attempt $i/12)"
            sleep 5
          done
          echo "‚ùå Pull secret not found"
          exit 1

  deployment:
    needs: [build-image, prepare-cluster]
    runs-on: ubuntu-slim
    permissions:
      contents: read
      packages: write
      deployments: write

    environment:
      name: production
      url: https://${{ needs.build-image.outputs.app_name }}.outatime.live

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: üîë Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

      # ==================== APPLY MANIFESTS ====================
      - name: üìù Prepare manifests
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          IMAGE="${{ needs.build-image.outputs.image }}:${{ github.sha }}"

          sed -i "s|{{APP_NAME}}|$APP_NAME|g" k8s/*.yaml
          sed -i "s|{{IMAGE}}|$IMAGE|g" k8s/*.yaml
          sed -i "s|{{DOMAIN}}|$APP_NAME.outatime.live|g" k8s/*.yaml

          echo "### Prepared Manifests" >> $GITHUB_STEP_SUMMARY
          echo '```yaml' >> $GITHUB_STEP_SUMMARY
          cat k8s/deployment.yaml >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: üöÄ Apply deployment
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl apply -f k8s/deployment.yaml -n $APP_NAME

      - name: üåê Apply service
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl apply -f k8s/service.yaml -n $APP_NAME

      - name: üîó Apply ingress
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl apply -f k8s/ingress.yaml -n $APP_NAME

      - name: ‚è≥ Wait for rollout
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl rollout status deployment/$APP_NAME -n $APP_NAME --timeout=120s

      # ==================== VERIFY ====================
      - name: üìä Get pod status
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl get pods -n $APP_NAME -o wide

      - name: üìä Get service status
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl get svc -n $APP_NAME

      - name: üìä Get ingress status
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          kubectl get ingress -n $APP_NAME

      - name: üìã Deployment summary
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"

          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY

          PODS=$(kubectl get pods -n $APP_NAME -o jsonpath='{.items[*].status.phase}')
          echo "| Pods | $PODS |" >> $GITHUB_STEP_SUMMARY

          READY=$(kubectl get deployment $APP_NAME -n $APP_NAME -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment $APP_NAME -n $APP_NAME -o jsonpath='{.spec.replicas}')
          echo "| Replicas | $READY/$DESIRED |" >> $GITHUB_STEP_SUMMARY

          echo "| URL | https://$APP_NAME.outatime.live |" >> $GITHUB_STEP_SUMMARY

  health-check:
    needs: [build-image, prepare-cluster, deployment]
    runs-on: ubuntu-slim
    permissions:
      contents: read
      packages: write
      deployments: write

    environment:
      name: production
      url: https://${{ needs.build-image.outputs.app_name }}.outatime.live

    steps:
      - name: üè• Health check
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          URL="https://$APP_NAME.outatime.live"

          echo "Checking $URL ..."

          for i in {1..30}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" $URL || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "‚úÖ App is live at $URL"
              exit 0
            fi
            echo "Attempt $i/30: Status $STATUS"
            sleep 10
          done

          echo "‚ùå Health check failed"
          exit 1

  clean-up:
    needs: [build-image, prepare-cluster, deployment, health-check]
    if: failure()
    runs-on: ubuntu-slim
    permissions:
      contents: read
      packages: write
      deployments: write

    environment:
      name: production
      url: https://${{ needs.build-image.outputs.app_name }}.outatime.live

    steps:
      - name: üõ†Ô∏è Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: üîë Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

      # ==================== CLEANUP ON FAILURE ====================
      - name: üßπ Cleanup failed new deployment
        if: needs.prepare-cluster.outputs.is_new == 'true'
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          echo "Cleaning up failed new deployment..."
          kubectl delete namespace $APP_NAME --ignore-not-found=true
          echo "‚úÖ Namespace $APP_NAME deleted"

      - name: ‚è™ Rollback failed update
        if: needs.prepare-cluster.outputs.is_new == 'false'
        run: |
          APP_NAME="${{ needs.build-image.outputs.app_name }}"
          echo "Rolling back failed update..."
          kubectl rollout undo deployment/$APP_NAME -n $APP_NAME
          kubectl rollout status deployment/$APP_NAME -n $APP_NAME --timeout=120s
          echo "‚úÖ Rollback complete"
